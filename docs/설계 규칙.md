설계 규칙
1. Langgraph 설계 규칙
	1. 하나의 노드에서는 최대 1회의 LLM 호출만 존재
		* LLM 출력은 Langgraph의 State에 나타나야 함
		* Send로 병렬처리하는 경우에는 State 다중 접근이 되므로 대부분의 경우 임시 State를 이용한 Subgraph로 구현
	2. 하나의 노드가 두개 이상의 역할을 수행 하지 말 것
		* 예시) LLM 호출 + Graph 동기화 → 규칙 위반
	3. 입력과 출력이 명시된 노드의 경우 LLM 호출 노드
		- Input에 명시된 것은 프롬프트에 반영되어야 하는 정보
		- Output에 명시된 것은 LLM 호출 결과로 얻어야 하는 정보
	4. 개별 구현한 Graph 객체의 경우 업데이트가 되면 이를 파일로 저장하는 노드가 반드시 연속되어야 함.
2. 서브그래프 파일 구조 규칙
	1. 노드 함수는 서브그래프 파일 내에 직접 선언
		* 각 서브그래프 파일(nodes/stage*_*.py)은 해당 서브그래프의 모든 노드를 포함
		* 서브그래프 파일만 읽으면 전체 로직을 파악할 수 있도록 자기완결적 구조 유지
	2. 공통 노드만 별도 파일에서 import
		* 여러 서브그래프에서 공통으로 사용되는 노드(예: initialize_accumulated_state, save_graph_to_file)만 nodes/stage*_nodes.py에서 import
		* 특정 서브그래프에만 사용되는 노드는 해당 파일 내에 선언
	3. 파일 왕복 최소화
		* 서브그래프 이해를 위해 여러 파일을 왔다갔다 할 필요 없도록 설계
		* 한 서브그래프 파일 = 노드 선언 + 조건부 엣지 + 서브그래프 빌드 함수
3. State 설계 규칙
	1. 메인 워크플로우 State와 서브그래프용 임시 State 분리
		* 메인 State: 전체 워크플로우에서 유지되어야 하는 핵심 정보 (graph, topic, iteration 등)
		* 임시 State: 특정 작업(Character/Event/Consolidation 생성 등)에서만 사용되는 정보
	2. Annotated 타입과 merge 함수 활용
		* Send로 병렬 처리시 결과를 누적하기 위해 Annotated[List[T], merge_lists] 패턴 사용
		* merge_lists: right가 None이면 초기화, 그 외에는 left + right
	3. 서브그래프 시작시 누적 State 초기화
		* initialize_accumulated_state 노드로 메인 State에서 필요한 정보만 복사하고 나머지는 None으로 초기화
		* 이전 iteration의 누적 데이터가 다음 iteration에 영향을 주지 않도록 보장
4. 병렬 처리 패턴
	1. Send API 활용
		* 조건부 엣지에서 List[Send] 반환하여 동일 노드를 독립적인 입력으로 병렬 실행
		* 각 Send는 독립적인 state 전달 (예: 역할별, 캐릭터별, PlaceHolder별)
	2. 병렬 처리 후 결과 누적
		* Annotated 타입의 merge 함수를 통해 각 병렬 실행 결과가 자동 병합
		* 모든 병렬 실행 완료 후 다음 노드로 진행
5. 반복 구조 설계
	1. iteration counter 관리
		* current_iteration: 현재 반복 횟수
		* max_iterations: 최대 반복 횟수
	2. 조건부 엣지로 반복 제어
		* should_continue 함수로 반복 계속 여부 결정
		* "continue" → 다음 작업 단계로, "end" → 종료 처리로
	3. 첫 반복과 이후 반복의 차이
		* 첫 반복: define_roles → Character → Event → Consolidation
		* 이후 반복: PlaceHolder Replace → Event → Consolidation
6. Utility 모듈 설계 규칙
	1. 디렉토리 구조
		* utils/ 디렉토리에 기능별로 하위 폴더 생성
		* 예: utils/cot/, utils/validation/ 등
	2. 모듈 구성
		* 서브그래프 패턴을 따르는 경우:
			- states.py: State 정의
			- nodes.py: 노드 구현 (각 노드 최대 1회 LLM 호출)
			- subgraph.py: 서브그래프 구성 및 조건부 엣지
			- extractor.py 또는 main.py: 메인 클래스 및 생성 함수
			- __init__.py: 외부에 공개할 함수/클래스 export
		* 단순 패턴 (서브그래프 없이 직접 구현):
			- extractor.py 또는 main.py: 메인 클래스 및 로직 구현
			- __init__.py: 외부에 공개할 함수/클래스 export
			- 예: CoT Extractor (단순 반복 루프로 구현, Pickle 호환성 보장)
	3. 인터페이스 일관성
		* 기존 패턴(예: create_extractor)과 동일한 인터페이스 제공
		* 사용자가 쉽게 교체하여 사용할 수 있도록 설계
	4. Import 경로
		* utils/__init__.py에서 주요 함수 re-export
		* 사용자는 `from utils import function_name` 또는 `from utils.module import function_name` 모두 가능
	5. Pickle 호환성 고려
		* LangGraph checkpoint 시스템과의 호환성을 위해 Pickle 가능한 객체만 State에 저장
		* 서브그래프가 필요한 경우: State에 unpicklable 객체(모델 객체 등) 넣지 않기
		* 대안: 단순 루프 구현으로 invoke() 메서드 내에서 처리
7. Model 및 Extractor 주입 패턴
	1. State 기반 주입
		* 모든 State에 model (str), extractor_type (str) 필드 추가
		* model: 모델 이름 (예: "gpt-4o-mini", "gpt-5-mini")
		* extractor_type: "default" (trustcall), "cot" (Chain of Thought), "plain" (일반 LLM)
	2. 노드에서 사용
		* `from utils import create_unified_extractor` 사용
		* 각 LLM 노드에서 `extractor = create_unified_extractor(model_name=state.get("model"), extractor_type=state.get("extractor_type", "default"), tools=[...], tool_choice="...")`
		* State에 model이 없으면 기본 모델 자동 사용
	3. 서브그래프 간 전달
		* initialize_accumulated_state에서 model, extractor_type 유지
		* 상위 State → 하위 State로 자동 전달
	4. 유연성
		* 워크플로우 전체에 하나의 모델 사용: InputState에 model 지정
		* 서브그래프별로 다른 모델 사용: Send에서 state에 model 재정의
		* 노드별로 다른 추론 방식: extractor_type 변경 (default ↔ cot)